//
// Created by imper on 6/21/21.
//

#ifndef INET_COMM_INET_COMM_
#define INET_COMM_INET_COMM_

# if defined(linux)

#  include <cassert>
#  include <thread>
#  include <sys/socket.h>
#  include <arpa/inet.h>
#  include <csignal>
#  include <net/if.h>
#  include <sys/ioctl.h>
#  include <sys/fcntl.h>
#  include <log-console>
#  include <ifaddrs.h>
#  include <openssl/ssl.h>
#  include <openssl/err.h>

#  define LOG_PREFIX log_console::l_lock << log_console::l_localtime << l_location
#  define ERR_PREFIX log_console::l_lock << log_console::l_localtime << l_location

#  define LOG (__detail__::_log_ << LOG_PREFIX)
#  define ERR (__detail__::_err_ << ERR_PREFIX)
#  define ENDENT color::reset << log_console::l_endent

#  define ERROR(message) (ERR << color::red << color::bold << "error" << color::reset << " : " << color::red << color::italic << message << color::reset << color::red << "." << ENDENT)
#  define FATAL_ERROR(message) ERROR(message); throw std::runtime_error(message)
#  define PRINT(stream, message) ((stream) << LOG_PREFIX << color::yellow << color::italic << message << color::reset << log_console::l_unlock)
#  define PRINTLN(stream, message) ((stream) << LOG_PREFIX << color::yellow << color::italic << message << ENDENT)

#  define DEFAULT_ERROR_HANDLER [](const char* str, size_t size, void* err_stream) { *static_cast<log_console*>(err_stream) << ERR_PREFIX << color::red << str << ENDENT; return 0; }

# else

#  ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
#  endif

#  define _WINSOCK_DEPRECATED_NO_WARNINGS
#  define _CRT_SECURE_NO_WARNINGS

#  include <windows.h>
#  include <winsock2.h>
#  include <ws2tcpip.h>
#  include <iphlpapi.h>
#  include <stdio.h>

#  pragma comment(lib, "Ws2_32.lib")

#  define LOG std::cout
#  define ERR std::cerr

#  define ERROR(message) (ERR << "error" << " : " << message << "\n")
#  define FATAL_ERROR(message) error(message); throw std::runtime_error(message)

typedef decltype(in_addr::S_un.S_addr) in_addr_t;
typedef ADDRESS_FAMILY sa_family_t;

# endif

# include <cstring>
# include <iostream>
# include <map>
# include <list>

namespace inetio
{
	namespace __detail__ __attribute__((visibility("hidden")))
	{
		static log_console _log_(stdout);
		static log_console _err_(stderr);

# if defined(linux)
		
		inline static SSL_CTX* init_server_ctx(const SSL_METHOD* method = DTLSv1_2_server_method())
		{
			SSL_CTX* ctx;
			
			OpenSSL_add_all_algorithms();  /* load & register all cryptos, etc. */
			SSL_load_error_strings();   /* load all error messages */
			
			ctx = SSL_CTX_new(method);   /* create new context from method */
			if (ctx == nullptr)
			{
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
				return ctx;
			}
			
			SSL_CTX_set_cipher_list(ctx, "ALL:eNULL");
			
			return ctx;
		}
		
		inline static SSL_CTX* init_client_ctx(const SSL_METHOD* method = DTLSv1_2_client_method())
		{
			SSL_CTX* ctx;
			
			OpenSSL_add_all_algorithms();  /* load & register all cryptos, etc. */
			SSL_load_error_strings();   /* load all error messages */
			
			ctx = SSL_CTX_new(method);   /* create new context from method */
			if (ctx == nullptr)
			{
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
				return ctx;
			}
			
			SSL_CTX_set_cipher_list(ctx, "ALL:eNULL");
			
			return ctx;
		}
		
		inline static bool load_certificates(SSL_CTX* ctx, const char* cert_file, const char* key_file)
		{
			if (SSL_CTX_load_verify_locations(ctx, cert_file, key_file) != 1)
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
			
			if (SSL_CTX_set_default_verify_paths(ctx) != 1)
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
			
			/** set the local certificate from CertFile **/
			if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
			{
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
				return false;
			}
			
			/** set the private key from KeyFile (may be the same as CertFile) **/
			SSL_CTX_set_default_passwd_cb_userdata(ctx, (void*)"14880");
			if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
			{
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, new log_console(stderr));
				return false;
			}
			
			/** verify private key **/
			if (!SSL_CTX_check_private_key(ctx))
			{
				*new log_console(stderr) << log_console::l_localtime << l_location << color::red
										 << "Private key does not match the public certificate" << ENDENT;
				return false;
			}
			
			/** Force the client-side have a certificate **/
			SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
			SSL_CTX_set_verify_depth(ctx, 4);
			
			return true;
		}
		
		inline static void print_cert_info(SSL* ssl, log_console& stream)
		{
			X509* cert;
			char* line;
			
			cert = SSL_get_peer_certificate(ssl); /* Get certificates (if available) */
			if (cert)
			{
				PRINTLN(stream, "Server certificates:");
				line = X509_NAME_oneline(X509_get_subject_name(cert), nullptr, 0);
				PRINTLN(stream, "Subject: " << color::blue << line);
				delete[] line;
				line = X509_NAME_oneline(X509_get_issuer_name(cert), nullptr, 0);
				PRINTLN(stream, "Issuer: " << color::blue << line);
				delete[] line;
				X509_free(cert);
			}
			else
			{
				PRINTLN(stream, "No certificates.");
			}
		}

# endif
	}
	
	template <typename type>
	concept send_datatype = std::is_same_v<std::remove_reference_t<type>, const char*> || std::is_same_v<std::remove_cvref_t<type>, const wchar_t*> ||
							std::is_same_v<std::remove_cvref_t<type>, std::string> || std::is_same_v<std::remove_cvref_t<type>, std::wstring> ||
							std::is_arithmetic_v<type>;
	
	template <typename type>
	concept receive_datatype = !std::is_const_v<type> && std::is_arithmetic_v<type>;

# if defined(linux)

/// Generates ECDSA key.
	inline EVP_PKEY* generate_key(std::string& error, const char* ec_type_name = "secp521r1")
	{
		/* Allocate memory for the EVP_PKEY structure. */
		EVP_PKEY* pkey = EVP_PKEY_new();
		if (!pkey)
		{
			error = "Unable to create EVP_PKEY structure.";
			return nullptr;
		}
		
		/* Allocate memory for the EC_KEY structure. */
		EC_KEY* ec_key = EC_KEY_new_by_curve_name(OBJ_txt2nid(ec_type_name));
		if (!ec_key)
		{
			error = "Unable to create EC_KEY structure.";
			return nullptr;
		}
		
		/* For cert signing, we use  the OPENSSL_EC_NAMED_CURVE flag*/
		EC_KEY_set_asn1_flag(ec_key, OPENSSL_EC_NAMED_CURVE);
		
		if (!EC_KEY_generate_key(ec_key))
		{
			error = "Unable to generate ECDSA key.";
			EC_KEY_free(ec_key);
			return nullptr;
		}
		
		if (!EVP_PKEY_assign_EC_KEY(pkey, ec_key))
		{
			error = "Unable to generate ECDSA key.";
			EC_KEY_free(ec_key);
			EVP_PKEY_free(pkey);
			return nullptr;
		}
		
		EC_KEY_free(ec_key);
		return pkey;
	}

/// Generates a self-signed x509 certificate.
	inline X509* generate_x509(
			std::string& error, EVP_PKEY* pkey, const char* country, const char* organization, const char* certificate_name,
			long serial_number = 1L, long valid_from = 0L, long valid_to = 31536000L)
	{
		/* Allocate memory for the X509 structure. */
		X509* x509 = X509_new();
		if (!x509)
		{
			error = "Unable to create X509 structure.";
			return nullptr;
		}
		
		/* Set the serial number. */
		ASN1_INTEGER_set(X509_get_serialNumber(x509), serial_number);
		
		/* This certificate is valid from <valid_from seconds> until exactly <valid_to seconds>. Default from now to one year. */
		X509_gmtime_adj(X509_get_notBefore(x509), valid_from);
		X509_gmtime_adj(X509_get_notAfter(x509), valid_to);
		
		/* Set the public key for our certificate. */
		X509_set_pubkey(x509, pkey);
		
		/* We want to copy the subject name to the issuer name. */
		X509_NAME* name = X509_get_subject_name(x509);
		
		/* Set the country code and common name. */
		X509_NAME_add_entry_by_txt(name, "C", MBSTRING_ASC, (unsigned char*)country, ::strlen(country), -1, 0);
		X509_NAME_add_entry_by_txt(name, "O", MBSTRING_ASC, (unsigned char*)organization, ::strlen(organization), -1, 0);
		X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char*)certificate_name, ::strlen(certificate_name), -1, 0);
		
		/* Now set the issuer name. */
		X509_set_issuer_name(x509, name);
		
		X509_NAME_free(name);
		
		/* Actually sign the certificate with our key. */
		if (!X509_sign(x509, pkey, EVP_sha1()))
		{
			error = "Error signing certificate.";
			X509_free(x509);
			return nullptr;
		}
		
		return x509;
	}
	
	inline bool write_certificate_to_disk(
			std::string& error, EVP_PKEY* pkey, X509* x509,
			const char* key_filename = "certificate.key", const char* x509_filename = "certificate.pem")
	{
		/* Open the PEM file for writing the key to disk. */
		FILE* pkey_file = ::fopen(key_filename, "wb");
		if (!pkey_file)
		{
			error = std::string("Unable to open file \"") + key_filename + "\" for writing.";
			return false;
		}
		
		/* Write the key to disk. */
		bool ret = ::PEM_write_PrivateKey(pkey_file, pkey, nullptr, nullptr, 0, nullptr, nullptr);
		::fclose(pkey_file);
		
		if (!ret)
		{
			error = "Unable to write private key to disk.";
			return false;
		}
		
		/* Open the PEM file for writing the certificate to disk. */
		FILE* x509_file = ::fopen(x509_filename, "wb");
		if (!x509_file)
		{
			error = std::string("Unable to open \"") + x509_filename + "\" for writing.";
			return false;
		}
		
		/* Write the certificate to disk. */
		ret = ::PEM_write_X509(x509_file, x509);
		::fclose(x509_file);
		
		if (!ret)
		{
			error = "Unable to write certificate to disk.";
			return false;
		}
		
		return true;
	}
	
	inline void cleanup_certificate(EVP_PKEY* key, X509* x509)
	{
		EVP_PKEY_free(key);
		X509_free(x509);
	}
	
	inline static void open_port_in_iptables(uint16_t port)
	{
		if (!geteuid())
		{
			LOG << color::faint << color::green << "executing opening ports command..." << ENDENT;
			std::string cmd("sudo iptables -A ");
			system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
			system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
			LOG << color::faint << color::green << "executed." << ENDENT;
		}
	}
	
	inline static void close_port_in_iptables(uint16_t port)
	{
		if (!geteuid())
		{
			LOG << color::faint << color::green << "executing opening ports command..." << ENDENT;
			std::string cmd("sudo iptables -D ");
			system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
			system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
			LOG << color::faint << color::green << "executed." << ENDENT;
		}
	}
	
	typedef struct ifinfo
	{
		struct sockaddr if_addr = {AF_INET};
		struct sockaddr if_broadaddr = {AF_INET};
		struct sockaddr if_dstaddr = {AF_INET};
		struct sockaddr if_hwaddr = {0};
		struct sockaddr if_netmask = {AF_INET};
		struct ifmap if_map = { };
		char if_name[IFNAMSIZ]{ };
		short int if_flags = 0;
		int if_index = -1;
		int if_mtu = -1;
	} ifinfo, * pifinfo;
	
	inline static struct ifinfo& get_interface_information(const char* interface_name)
	{
		auto& result = *new ifinfo{ };
		int fd = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
		
		/* define the ifr_name - port name where network attached */
		::memcpy(result.if_name, interface_name, IFNAMSIZ - 1);
		
		/* address of the device using */
		struct ifreq tmp{ };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFADDR, &tmp);
		::memcpy(result.if_addr.sa_data, tmp.ifr_addr.sa_data, 14);
		
		/* broadcast address for a device */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFBRDADDR, &tmp);
		::memcpy(result.if_broadaddr.sa_data, tmp.ifr_broadaddr.sa_data, 14);
		
		/* destination address of a point-to-point device */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFDSTADDR, &tmp);
		::memcpy(result.if_dstaddr.sa_data, tmp.ifr_dstaddr.sa_data, 14);
		
		/* active flag word of the device */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFFLAGS, &tmp);
		result.if_flags = tmp.ifr_flags;
		
		/* hardware (MAC) address */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFHWADDR, &tmp);
		::memcpy(result.if_hwaddr.sa_data, tmp.ifr_hwaddr.sa_data, 14);
		
		/* index of the interface */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFINDEX, &tmp);
		result.if_index = tmp.ifr_ifindex;
		
		/* interface's hardware parameters */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFMAP, &tmp);
		result.if_map = tmp.ifr_map;
		
		/* MTU (Maximum Transfer Unit) of a device */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFMTU, &tmp);
		result.if_mtu = tmp.ifr_mtu;
		
		/* network mask for a device */
		tmp = { };
		::memcpy(tmp.ifr_name, interface_name, IFNAMSIZ - 1);
		::ioctl(fd, SIOCGIFNETMASK, &tmp);
		::memcpy(result.if_netmask.sa_data, tmp.ifr_netmask.sa_data, 14);
		
		::close(fd);
		return result;
	}
	
	inline static std::list<struct ifaddrs*>& list_all_network_interfaces()
	{
		auto& result = *new std::remove_cvref_t<decltype(list_all_network_interfaces())>();
		
		struct ifaddrs* ifaddr, * ifa;
		
		if (::getifaddrs(&ifaddr) == -1)
		{
			ERROR("getifaddrs() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno));
			return result;
		}
		
		for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
		{
			if (ifa->ifa_addr == nullptr || ifa->ifa_addr->sa_family != AF_PACKET) continue;
			result.push_back(ifa);
		}
		return result;
	}
	
	inline static std::list<struct ifaddrs*>& list_all_network_addresses()
	{
		auto& result = *new std::remove_cvref_t<decltype(list_all_network_addresses())>();
		
		struct ifaddrs* ifaddr, * ifa;
		
		if (::getifaddrs(&ifaddr) == -1)
		{
			ERROR("getifaddrs() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno));
			return result;
		}
		
		for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
		{
			if (ifa->ifa_addr == nullptr) continue;
			result.push_back(ifa);
		}
		return result;
	}

# endif
	
	inline in_addr_t inet_pton(sa_family_t af, const char* address)
	{
		in_addr_t ret{0};
		::inet_pton(af, address, &ret);
		return ret;
	}

# if defined(linux)
	
	class suppress_signal
	{
	public:
		inline explicit suppress_signal(int _sig) : sig(_sig)
		{ ::signal(_sig, sig_handle); }
		
		inline ~suppress_signal()
		{ ::signal(this->sig, SIG_DFL); }
		
		inline static void enable_log(bool status = true)
		{ if (status) _log_ << log_console::on; else _log_ << log_console::off; }
		
		inline static void enable_err(bool status = true)
		{ if (status) _err_ << log_console::on; else _err_ << log_console::off; }
	
	private:
		int sig;
		
		inline static void sig_handle(int sig)
		{ ERROR(::sigabbrev_np(sig) << " " << color::bold << ::sigdescr_np(sig)); }
		
		static log_console _log_;
		static log_console _err_;
	};

// # definition-begin suppress_signal
	
	log_console suppress_signal::_log_(stdout);
	log_console suppress_signal::_err_(stderr);

// # definition-end suppress_signal
# endif
	
	class server;
	
	class inet_address
	{
	public:
		inline inet_address() = default;
		
		inline inet_address(const sockaddr_in& address) : address(address)
		{ }
		
		inline inet_address(sa_family_t family, uint16_t port, in_addr_t address)
				: inet_address(
				*new sockaddr_in{
						family, ::htons(port),
# if defined(linux)
						in_addr{address}}
# else
				in_addr{.S_un = {.S_addr = address}}}
# endif
		)
		{ }
		
		inline inet_address(sa_family_t family, uint16_t port, const std::string& address)
				: inet_address(family, port, inet_pton(family, address.c_str()))
		{ }
		
		inline static inet_address& from_ipv4(const std::string& address, uint16_t default_port)
		{
			auto& addr = *new inet_address;
			size_t pos = address.find(':');
			if (pos == std::string::npos)
			{
				addr.set_address(AF_INET, address.c_str());
				addr.set_port(default_port);
			}
			else
			{
				addr.set_address(AF_INET, address.substr(0, pos).c_str());
				if (++pos < address.size())
				{
					addr.set_port(std::stoul(address.substr(pos, address.size() - pos)));
				}
				else
				{
					addr.set_port(default_port);
				}
			}
			return addr;
		}
		
		inline static inet_address& from_ipv6(const std::string& address, uint16_t default_port)
		{
			auto& addr = *new inet_address;
			size_t pos = address.find(']');
			int shift = address.starts_with('[');
			if (pos == std::string::npos)
			{
				addr.set_address(AF_INET6, address.c_str());
				addr.set_port(default_port);
			}
			else
			{
				addr.set_address(AF_INET6, address.substr(0, pos).c_str() + shift);
				if (shift) ++ ++pos;
				if (pos < address.size())
				{
					addr.set_port(std::stoul(address.substr(pos, address.size() - pos)));
				}
				else
				{
					addr.set_port(default_port);
				}
			}
			return addr;
		}
		
		[[nodiscard]] inline const char* get_address() const
		{ return ::inet_ntoa(this->address.sin_addr); }
		
		[[nodiscard]] inline uint16_t get_port() const
		{ return ::ntohs(this->address.sin_port); }
		
		[[nodiscard]] inline sa_family_t get_family() const
		{ return this->address.sin_family; }
		
		[[nodiscard]] inline sockaddr_in get_raw() const
		{ return this->address; }
		
		inline void set_address(sa_family_t family, const char* address)
		{
			::inet_pton(family, address, &this->address.sin_addr.s_addr);
			this->address.sin_family = family;
		}
		
		inline void set_port(uint16_t port)
		{ this->address.sin_port = ::htons(port); }
		
		inline operator sockaddr_in() const
		{ return this->operator const sockaddr_in&(); }
		
		inline operator const sockaddr_in&() const
		{ return this->address; }
	
	private:
		friend class server;
		
		friend class inet_io;
		
		sockaddr_in address;
	};


# if defined (linux)
	
	typedef bool (* client_process_function)(int socket, SSL* ssl, const inet_address& address, server* server);

# else
	
	typedef bool (* client_process_function)(SOCKET socket, const inet_address& address, server* server);

# endif
	
	class server
	{
	public:
		struct server_client_data
		{
# if defined(linux)
			int socket;
			std::map<int, bool>* is_client_processing_ptr;
			SSL* ssl;
# else
			SOCKET socket;
			std::map<SOCKET, bool>* is_client_processing_ptr;
# endif
			inet_address address;
			server* serv;
			client_process_function process_function;
			int thread_id;
			int* threads_count;
		};
		
		inline server(
				int max_clients, const inet_address& address, client_process_function process_function, void* extra, const std::string& cert_file,
				const std::string& key_file);
		
		inline bool run(bool wait);

# if defined(linux)
		
		inline static void* server_thread(void* args);

# else
		
		inline static DWORD WINAPI server_thread(void* args);

# endif
		
		inline void run_server_thread(bool wait_for_child_threads);
		
		inline static void wait_for_all_servers();

# if defined(linux)
		
		[[nodiscard]] int get_socket() const;

# else
		
		[[nodiscard]] SOCKET get_socket() const;

# endif
		
		[[nodiscard]] inline int get_max_clients() const
		{ return max_clients; }
		
		[[nodiscard]] inline const inet_address& get_address() const
		{ return this->address; }
		
		[[nodiscard]] inline client_process_function get_process_function() const
		{ return process_function; }
		
		[[nodiscard]] inline const std::string& get_cert_file() const
		{ return cert_file; }
		
		[[nodiscard]] inline const std::string& get_key_file() const
		{ return key_file; }
		
		inline ~server();
		
		void* extra;
	
	private:
# if defined(linux)
		
		inline static void* process_client(void* args);
		
		pthread_t main_thread = 0;
		int socket;
		SSL_CTX* ctx = nullptr;

# else
		
		inline static DWORD WINAPI process_client(void* args);
		
		SOCKET socket;
		HANDLE main_thread = nullptr;

# endif
		bool wait_for_child_threads = false;
		
		int max_clients;
		inet_address address;
		client_process_function process_function;
# if defined(linux)
		static pthread_mutex_t mutex;
		std::string cert_file;
		std::string key_file;
# endif
		static int server_threads;
	};
	
	
	class inet_io
	{
	public:
# if defined(linux)
		
		inline inet_io(int socket) : socket(socket), ssl(nullptr)
		{ }
		
		inline inet_io(SSL* ssl) : socket(ssl ? SSL_get_fd(ssl) : -1), ssl(ssl)
		{ }

# else
		
		inline inet_io(SOCKET socket) : socket(socket)
		{ }

# endif

# if defined(linux)
		
		template <size_t max_attempts = 0>
		inline bool write(const void* data, size_t size);

# else
		
		inline bool write(const char* data, size_t size);

# endif

# if defined(linux)
		
		inline ssize_t read(void* data, size_t size, bool non_block);
		
		[[nodiscard]] inline int get_socket() const
		{ return socket; }
		
		[[nodiscard]] inline SSL* get_ssl() const
		{ return this->ssl; }

# else
		
		inline size_t read(char* data, size_t size);
	
		[[nodiscard]] inline SOCKET get_socket() const;

# endif
		
		inline operator bool() const;
	
	protected:
		template <send_datatype type>
		friend inline inet_io& operator<<(inet_io& io, type data);
		
		template <receive_datatype type>
		friend inline inet_io& operator>>(inet_io& io, type& data);

# if defined(linux)
		int socket;
		SSL* ssl;
# else
		SOCKET socket;
# endif
		bool success = true;
	};
	
	
	class client : public inet_io
	{
	public:
# if defined(linux)
		
		inline client(
				const inet_address& server_address, bool ssl_connection, SSL* ssl, SSL_CTX* ctx,
				const std::string& cert_file, const std::string& key_file);

# else
		
		inline client(const inet_address& server_address);

# endif
		
		inline bool connect();
		
		[[nodiscard]] inline uint16_t get_port() const
		{ return this->server_address.get_port(); }
		
		[[nodiscard]] inline const inet_address& get_server_address() const
		{ return server_address; }

# if defined(linux)
		
		[[nodiscard]] SSL_CTX* get_ctx() const
		{ return this->ctx; }

# endif
		
		inline ~client();
	
	private:
		inet_address server_address;
		SSL_CTX* ctx;
		std::string cert_file;
		std::string key_file;
	};


// #definition-begin server
	
	int server::server_threads = 0;

# if defined(linux)
	pthread_mutex_t server::mutex = PTHREAD_MUTEX_INITIALIZER;
	
	
	inline server::server(
			int max_clients, const inet_address& address, client_process_function process_function, void* extra = nullptr,
			const std::string& cert_file = "", const std::string& key_file = "") :
			max_clients(max_clients), address(address), process_function(process_function), extra(extra), cert_file(cert_file), key_file(key_file)
	{
		LOG << color::green << "socket init...\nserver address: " << color::yellow << address.get_address()
			<< color::green << ";\nsocket family: " << address.get_family()
			<< color::green << ";\nport = " << address.get_port()
			<< color::green << ";\n\tmax connections accept = " << max_clients
			<< color::green << ";" << ENDENT;
		socket = ::socket(AF_INET, SOCK_STREAM, 0);
		if (socket < 0)
		{
			ERROR(
					"socket() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset
									   << color::red << ". socket : " << socket << ". this = " << this
			);
			return;
		}
		
		if (int ret = ::setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char*)(new int(1)), sizeof(int)); ret < 0)
		{
			ERROR(
					"setsockopt() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
										   << ". this = " << this
			);
			return;
		}
		
		LOG << color::green << "binding..." << ENDENT;
		if (int ret = ::bind(socket, (struct sockaddr*)&address.address, sizeof(address.address)); ret < 0)
		{
			ERROR(
					"bind() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
									 << ". this = " << this
			);
			return;
		}
		
		LOG << color::green << "success.\n" << color::reset
			<< color::green << "listening socket = " << color::reset << socket << color::green << " ...\n" << color::reset
			<< color::green << "listen..." << ENDENT;
		if (listen(socket, max_clients) < 0)
		{
			ERROR(
					"listen() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
									   << ". this = " << this
			);
			return;
		}
		
		if (!this->cert_file.empty() && !this->key_file.empty())
		{
			LOG << color::green << "initializing ctx..." << ENDENT;
			this->ctx = __detail__::init_server_ctx();
			
			LOG << color::green << "loading certificates..." << ENDENT;
			if (!__detail__::load_certificates(this->ctx, this->cert_file.c_str(), this->key_file.c_str()))
			{
				ERROR("load_certificates() returned " << false << color::red << ". this = " << this);
			}
		}
		
		LOG << color::green << "success." << ENDENT;
	}

# else
	
	inline server::server(int max_clients, const inet_address& address, client_process_function process_function, void* extra)
			: max_clients(max_clients), address(address), process_function(process_function), extra(extra)
	{
		LOG << "winsock lib init...\n";
	
		WSADATA wsa;
	
		if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		{
			ERROR("WSAStartup() failed with error " << WSAGetLastError());
			return;
		}
	
		LOG << "done.\n";
	
		LOG << "socket init...\nserver address: " << address.get_address()
			<< ";\nsocket family: " << address.get_family()
			<< ";\nport = " << address.get_port()
			<< ";\n\tmax connections accept = " << max_clients
			<< ";\n";
		socket = ::socket(AF_INET, SOCK_STREAM, 0);
		if (socket == INVALID_SOCKET)
		{
			ERROR("socket() failed with error " << GetLastError() << ". socket : " << socket);
			return;
		}
		
		if (int ret = ::setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char*)(new int(1)), sizeof(int)); ret < 0)
		{
			ERROR("setsockopt() failed with error" << GetLastError());
			return;
		}
		
		LOG << "binding...\n";
		if (int ret = ::bind(socket, (struct sockaddr*)&address.address, sizeof(address.address)); ret < 0)
		{
			ERROR("bind() failed with error " << GetLastError());
			return;
		}
		
		LOG << "success.\n"
			<< "listening socket = " << socket << " ...\n"
			<< "listen...\n";
		if (listen(socket, max_clients) < 0)
		{
			ERROR("listen() failed with error " << GetLastError());
			return;
		}
		LOG << "success.\n";
	}

# endif

# if defined(linux)
	
	inline bool server::run(bool wait = false)
	{
		int threads_count = 0, thread_id = 0;
		
		std::map<int, bool> is_client_processing;
		
		struct sockaddr_in address{ };
		socklen_t addrlen = sizeof(address);
		
		int new_socket;
		
		while (true)
		{
			if (new_socket = ::accept(this->socket, (struct sockaddr*)&address, &addrlen); new_socket < 0)
			{
				ERROR("accept() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
										 << ". this = " << this
				);
				if (errno == EBADF || errno == EINVAL)
				{
					return false;
				}
				break;
			}
			
			LOG << color::green << "====== new connection ======\n socket = " << color::reset << new_socket
				<< color::green << "\n address = " << color::yellow << ::inet_ntoa(address.sin_addr)
				<< color::green << "\n port = " << color::reset << ::ntohs(address.sin_port)
				<< color::green << "\n\n============================" << ENDENT;
			
			SSL* ssl = nullptr;
			
			if (this->ctx)
			{
				ssl = SSL_new(ctx); /** get new SSL state with context **/
				if (!ssl)
				{
					ERROR("SSL_new() returned " << color::italic << color::purple << "nullptr" << ". this = " << this);
				}
				
				if (!SSL_set_fd(ssl, new_socket)) /** set connection socket to SSL state **/
				{
					ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
				}
				
				if (ssl)
				{
					if (SSL_accept(ssl) <= 0)
					{
						ERROR("SSL_accept() failed. this = " << this);
						ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
						ssl = nullptr;
					}
				}
				
				__detail__::print_cert_info(ssl, __detail__::_log_);
			}
			
			auto* dat = new server_client_data{ };
			dat->socket = new_socket;
			dat->ssl = ssl;
			dat->serv = const_cast<server*>(this);
			dat->address = inet_address(address);
			dat->is_client_processing_ptr = &is_client_processing;
			dat->thread_id = ++thread_id;
			dat->threads_count = &++threads_count;
			dat->process_function = process_function;
			
			LOG << color::green << "running client processing thread..." << ENDENT;
			
			pthread_t pthread;
			pthread_create(&pthread, nullptr, process_client, (void*)dat);
			::pthread_detach(pthread);
			
			LOG << color::green << "done." << ENDENT;
		}
		
		while (wait && threads_count > 0)
		{
			::usleep(10000);
		}
		
		return true;
	}

# else
	
	inline bool server::run(bool wait) const
	{
		int threads_count = 0, thread_id = 0;
		
		std::map<SOCKET, bool> is_client_processing;
		
		struct sockaddr_in address{ };
		int addrlen = sizeof(address);
	
		SOCKET new_socket;
		
		while (true)
		{
			if (new_socket = ::accept(this->socket, (struct sockaddr*)&address, &addrlen); new_socket < 0)
			{
				ERROR("accept() failed with error " << GetLastError());
				if (errno == EBADF || errno == EINVAL)
				{
					return false;
				}
				break;
			}
			
			LOG << "====== new connection ======\n socket = " << new_socket
				<< "\n address = " << ::inet_ntoa(address.sin_addr)
				<< "\n port = " << ::ntohs(address.sin_port)
				<< "\n\n============================\n";
			
			auto* dat = new server_client_data{ };
			dat->socket                   = new_socket;
			dat->serv                     = const_cast<server*>(this);
			dat->address                  = address;
			dat->is_client_processing_ptr = &is_client_processing;
			dat->thread_id                = ++thread_id;
			dat->threads_count            = &++threads_count;
			dat->process_function         = process_function;
			
			LOG << "running client processing thread...\n";
	
			CreateThread(nullptr, 0, process_client, (void*)dat, 0, 0);
			
			LOG << "done.\n";
		}
		
		while (wait && threads_count > 0)
		{
			Sleep(10);
		}
		
		return true;
	}

# endif

# if defined(linux)
	
	inline void* server::server_thread(void* args)
# else
	inline DWORD WINAPI server::server_thread(void* args)
# endif
	{
		auto* server = static_cast<class server*>(args);
		while (server->run(server->wait_for_child_threads))
		{ }
		--server::server_threads;
# if defined(linux)
		return new bool(true);
# else
		return 0;
# endif
	}
	
	inline void server::run_server_thread(bool wait_for_child_threads = false)
	{
		this->wait_for_child_threads = wait_for_child_threads;
		++server::server_threads;
# if defined(linux)
		LOG << color::faint << color::yellow << "starting main server thread..." << ENDENT;
		pthread_create(&this->main_thread, nullptr, server_thread, static_cast<void*>(const_cast<server*>(this)));
		pthread_detach(this->main_thread);
		LOG << color::faint << color::yellow << "done." << ENDENT;
# else
		LOG << "starting main server thread...\n";
		this->main_thread = CreateThread(nullptr, 0, server_thread, static_cast<void*>(const_cast<server*>(this)), 0, 0);
		LOG << "done.\n";
# endif
	}
	
	inline void server::wait_for_all_servers()
	{
		while (server::server_threads > 0)
		{
# if defined(linux)
			::usleep(10000);
# else
			Sleep(10);
# endif
		}
	}

# if defined(linux)
	
	inline void* server::process_client(void* args)
	{
		pthread_mutex_lock(&mutex);
		struct server_client_data& data = *static_cast<struct server_client_data*>(args);
		int client_socket = data.socket;
		LOG << color::green << "\nsocket : " << client_socket << ENDENT;
		if ((*data.is_client_processing_ptr)[client_socket])
		{
			return nullptr;
		}
		(*data.is_client_processing_ptr)[client_socket] = true;
		pthread_mutex_unlock(&mutex);
		
		LOG << color::green << "processing client...\n\tthread_no = " << data.thread_id << color::green << "; this = " << data.serv
			<< ENDENT;
		while (data.process_function(data.socket, data.ssl, data.address, data.serv))
		{ }
		LOG << color::green << "SSL_free()..." << ENDENT;
		SSL_free(data.ssl);
		LOG << color::faint << "job finished.\n\tthread_no = " << data.thread_id << ";" << ENDENT;
		(*data.is_client_processing_ptr)[client_socket] = false;
		--*data.threads_count;
		return nullptr;
	}
	
	inline int server::get_socket() const
	{
		return socket;
	}

# else
	
	inline DWORD WINAPI server::process_client(void* args)
	{
		struct server_client_data& data = *static_cast<struct server_client_data*>(args);
		SOCKET client_socket = data.socket;
		LOG << "\nsocket : " << client_socket << "\n";
		if ((*data.is_client_processing_ptr)[client_socket])
		{
			return 0;
		}
		(*data.is_client_processing_ptr)[client_socket] = true;
		
		LOG << "processing client...\n\tthread_no = " << data.thread_id << ";\n";
		while (data.process_function(data.socket, data.address, data.serv))
		{ }
		LOG << "job finished.\n\tthread_no = " << data.thread_id << ";\n";
		return 0;
	}
	
	inline SOCKET server::get_socket() const
	{
		return socket;
	}

# endif
	
	inline server::~server()
	{
# if defined(linux)
		LOG << color::faint << color::yellow << "destruction of server(); this = " << this << ENDENT;
		pthread_kill(this->main_thread, 0);
		::close(this->socket);
		SSL_CTX_free(this->ctx);
# else
		TerminateThread(this->main_thread, 0);
		closesocket(this->socket);
		WSACleanup();
# endif
	}

// #definition-end server

// #definition-begin inet_io
# if defined(linux)
	
	template <size_t max_attempts>
	inline bool inet_io::write(const void* data, size_t size)
# else
	bool inet_io::write(const char* data, size_t size)
# endif
	{
		this->success = true;

# if defined(linux)
		ssize_t wrote;
		if (this->ssl)
		{
			wrote = SSL_write(this->ssl, data, size);
			if (!wrote)
			{
				ERR << "this = " << this << ENDENT;
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
			}
		}
		else
		{
			wrote = ::write(this->socket, data, size);
		}
		
		auto* data_iter = reinterpret_cast<const char*>(data);
		
		if (wrote < 0)
		{
			goto fail;
		}
		
		for (size_t attempt = 0; wrote < size && attempt < max_attempts; ++attempt)
		{
			LOG << color::faint << color::green << "wrote only " << wrote << color::green << "bytes of data - trying to write rest." << ENDENT;
			data_iter += wrote;
			size -= wrote;
			size_t local_wrote;
			if (this->ssl)
				wrote = SSL_write(this->ssl, data_iter, size);
			else
				wrote = ::write(this->socket, data_iter, size);
			
			if (wrote < 0)
			{
				goto fail;
			}
		}
		
		if (wrote <= 0)
		{
			goto fail;
		}
# else
		int wrote = send(this->socket, data, size, 0);
		if (wrote == SOCKET_ERROR)
		{
			error("send() failed with error: " << WSAGetLastError());
			goto fail;
		}
# endif
		
		this->success = wrote == size;
		
		return wrote == size;

fail:
# if defined(linux)
		ERR << "this = " << this << ENDENT;
		if (this->ssl)
			ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
		else
			ERROR("write() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno));
# endif
		this->success = false;
		return false;
	}

# if defined(linux)
	
	inline ssize_t inet_io::read(void* data, size_t size, bool non_block = false)
	{
		this->success = true;
		int flags;
		if (non_block)
		{
			flags = fcntl(this->socket, F_GETFL, 0);
			if (::fcntl(this->socket, F_SETFL, flags | O_NONBLOCK) < 0)
			{
				ERROR(
						"fcntl() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
										  << ". this = " << this
				);
				this->success = false;
			}
		}
		
		ssize_t read;
read_again:
		if (this->ssl)
			read = SSL_read(this->ssl, data, size);
		else
			read = ::read(this->socket, data, size);
		
		if (read <= 0)
		{
			ERR << "this = " << this << ENDENT;
			
			if (non_block)
			{
				if (::fcntl(this->socket, F_SETFL, flags))
				{
					ERROR(
							"fcntl() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset
											  << color::red << ". this = " << this
					);
					this->success = false;
				}
			}
			
			if (this->ssl)
			{
				if (ERR_get_error() == SSL_ERROR_WANT_READ) goto read_again;
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
			}
			else
			{
				if (errno == EINPROGRESS) goto read_again;
				ERROR("read() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno));
			}
			
			this->success = false;
		}
		
		if (non_block)
		{
			if (::fcntl(this->socket, F_SETFL, flags))
			{
				ERROR(
						"fcntl() failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
										  << ". this = " << this
				);
				this->success = false;
			}
		}
		
		return read;
	}

# else
	
	inline size_t inet_io::read(char* data, size_t size)
	{
		this->success = true;
	
		int read = ::recv(this->socket, data, size, 0);
		if (read <= 0)
		{
			error("read() failed with error: " << GetLastError());
			this->success = false;
			return 0;
		}
	
		return read;
	}
	
	inline SOCKET inet_io::get_socket() const
	{ return socket; }

# endif
	
	inline inet_io::operator bool() const
	{ return this->success; }
	
	template <send_datatype type>
	inline inet_io& operator<<(inet_io& io, type data)
	{
		if constexpr(std::is_same_v<std::remove_cvref_t<type>, const char*>)
			io.write(data, strlen(data));
		else if constexpr(std::is_same_v<std::remove_cvref_t<type>, const wchar_t*>)
			io.write(static_cast<const void*>(data), wcslen(data) * sizeof(*data));
		else if constexpr(std::is_same_v<std::remove_cvref_t<type>, std::string> || std::is_same_v<std::remove_cvref_t<type>, std::wstring>)
			io.write(static_cast<const void*>(data.c_str()), data.size() * sizeof(typename std::remove_cvref_t<type>::value_type));
		else if constexpr(std::is_arithmetic_v<type>)
			io.write(static_cast<const void*>(&data), sizeof(data));
		else
			static_cast<type>(new type); // invalid data type
		
		return io;
	}
	
	template <receive_datatype type>
	inline inet_io& operator>>(inet_io& io, type& data)
	{
		if constexpr(!std::is_const_v<type> && std::is_arithmetic_v<type>)
			io.read(static_cast<void*>(&data), sizeof(data));
		else
			static_cast<type>(new type); // invalid data type
		
		return io;
	}

// #definition-end inet_io

// #definition-begin client

# if defined(linux)
	
	inline client::client(
			const inet_address& server_address, bool ssl_connection = false, SSL* ssl = nullptr, SSL_CTX* ctx = nullptr,
			const std::string& cert_file = "", const std::string& key_file = "")
			: inet_io(ssl), server_address(server_address), cert_file(cert_file), key_file(key_file)
	{
		LOG << color::green << "socket init...\nserver address: " << color::yellow << this->server_address.get_address()
			<< color::green << ";\nsocket family: " << this->server_address.get_family()
			<< color::green << ";\nport = " << this->server_address.get_port() << color::green << ";"
			<< ENDENT;
		
		
		this->socket = ::socket(AF_INET, SOCK_STREAM, 0);
		if (this->socket < 0)
		{
			ERROR(
					"socket init failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno) << color::reset << color::red
										  << ". socket : " << socket << ". this = " << this
			);
			return;
		}
		
		this->ctx = ctx;
		if (this->ctx == nullptr && ssl_connection)
		{
			LOG << color::green << "initializing ctx..." << ENDENT;
			this->ctx = __detail__::init_client_ctx();
			if (!this->cert_file.empty() && !this->key_file.empty())
			{
				LOG << color::green << "loading certificates..." << ENDENT;
				if (!__detail__::load_certificates(this->ctx, this->cert_file.c_str(), this->key_file.c_str()))
				{
					ERROR("load_certificates() returned " << false << color::red << ". this = " << this);
				}
			}
		}
		
		LOG << color::green << "success." << ENDENT;
	}

# else
	
	inline client::client(const inet_address& server_address) :
			server_address(server_address)
	{
		LOG << "socket init...\nserver address: " << this->server_address.get_address()
			<< ";\nsocket family: " << this->server_address.get_family()
			<< ";\nport = " << this->server_address.get_port() << ";\n";
		this->socket = ::socket(AF_INET, SOCK_STREAM, 0);
		if (this->socket == INVALID_SOCKET)
		{
			error("socket init failed with error: " << GetLastError());
			return;
		}
		
		LOG << "success.\n";
	}

# endif
	
	inline bool client::connect()
	{
# if defined(linux)
		LOG << color::green << "connecting..." << ENDENT;
		
		if (::connect(socket, (struct sockaddr*)&this->server_address, sizeof(this->server_address)) < 0)
		{
			ERROR("connection failed " << ::strerrorname_np(errno) << " " << color::bold << ::strerrordesc_np(errno));
			return false;
		}
		
		if (!this->ssl && this->ctx)
		{
			LOG << color::green << "SSL_new()..." << ENDENT;
			this->ssl = SSL_new(this->ctx);
		}
		
		if (this->ssl)
		{
			SSL_set_fd(this->ssl, this->socket);
			
			LOG << color::green << "SSL_connect()..." << ENDENT;
			
			if (SSL_connect(ssl) <= 0)
			{
				ERR << "this = " << this << ENDENT;
				ERR_print_errors_cb(DEFAULT_ERROR_HANDLER, &__detail__::_err_);
				this->ssl = nullptr;
			}
			
			__detail__::print_cert_info(ssl, __detail__::_log_);
		}
		
		LOG << color::green << "success." << ENDENT;
# else
		LOG << "connecting...\n";
		if (::connect(socket, (struct sockaddr*)&this->server_address, sizeof(this->server_address)) == SOCKET_ERROR)
		{
			error("connect() failed with error: " << GetLastError());
			closesocket(socket);
			socket = INVALID_SOCKET;
			return false;
		}
	
		LOG << "success.\n";
# endif
		return true;
	}
	
	inline client::~client()
	{
# if defined(linux)
		LOG << color::faint << color::yellow << "destruction of client(); this = " << this << ENDENT;
		::close(this->socket);
		SSL_free(this->ssl);
# else
		closesocket(this->socket);
# endif
	}

// #definition-end client
}

#endif // INET_COMM_INET_COMM_