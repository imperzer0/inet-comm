//
// Created by imper on 6/21/21.
//

#ifndef INET_COMM
#define INET_COMM

#if defined(linux)

#include <cassert>
#include <thread>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <csignal>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <log-console>
#include <ifaddrs.h>

#else

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <stdio.h>

#pragma comment(lib, "Ws2_32.lib")

#endif

#include <cstring>
#include <iostream>
#include <map>
#include <vector>


#if defined(linux)

#define log log_ << log_console::l_lock << l_time << l_location
#define err err_ << log_console::l_lock << l_time << l_location

#define error(message) (log << color::red << color::bold << "error" << color::reset << " : " << color::red << color::italic << message << color::reset << log_console::l_endent)
#define fatal_error(message) error(message); throw std::runtime_error(message)

#else

#define log std::cout
#define err std::cerr

#define error(message) (err << "error" << " : " << message << "\n")
#define fatal_error(message) error(message); throw std::runtime_error(message)

#endif


#if defined(linux)

class suppress_signal
{
public:
	explicit suppress_signal(int _sig) : _sig(_sig)
	{
		::signal(_sig, _sig_handle);
	}
	
	~suppress_signal()
	{
		::signal(this->_sig, SIG_DFL);
	}
	
	static void enable_log(bool status = true);
	
	static void enable_err(bool status = true);

private:
	int _sig;
	
	static void _sig_handle(int _sig);
	
	static log_console log_;
	static log_console err_;
};

// #definition-begin suppress_signal

log_console suppress_signal::log_(stdout);
log_console suppress_signal::err_(stderr);

void suppress_signal::_sig_handle(int _sig)
{
	error(::strsignal(_sig));
}

void suppress_signal::enable_log(bool status)
{
	if (status) log_ << log_console::on;
	else log_ << log_console::off;
}

void suppress_signal::enable_err(bool status)
{
	if (status) log_ << log_console::on;
	else log_ << log_console::off;
}

// #definition-end suppress_signal
#endif

class server;

#if defined (linux)

typedef bool (* client_process_function)(int socket, const sockaddr_in& address, server* server);

#else

typedef bool (* client_process_function)(SOCKET socket, const sockaddr_in& address, server* server);

#endif

struct server_client_data
{
#if defined(linux)
	int socket;
	std::map<int, bool>* is_client_processing_ptr;
#else
	SOCKET socket;
	std::map<SOCKET, bool>* is_client_processing_ptr;
#endif
	sockaddr_in address;
	server* serv;
	client_process_function process_function;
	int                     thread_id;
	int* threads_count;
};

class server
{
public:
	server(int max_clients, const struct sockaddr_in& address, client_process_function process_function, void* extra = nullptr);
	
	[[nodiscard]] bool run(bool wait = false) const;

#if defined(linux)
	
	static void* server_thread(void* args);

#else
	
	static DWORD WINAPI server_thread(void* args);

#endif
	
	void run_server_thread(bool wait_for_child_threads = false);
	
	static void wait_for_all_servers();

#if defined(linux)
	
	static void open_port_in_iptables(uint16_t port);
	
	static void close_port_in_iptables(uint16_t port);
	
	static void get_machine_ip(struct ifreq& result, const char* interface_name);
	
	static std::vector<struct ifaddrs*>& list_all_network_interfaces();
	
	[[nodiscard]] int get_socket() const;

#else
	
	[[nodiscard]] SOCKET get_socket() const;

#endif
	
	[[nodiscard]] int get_max_clients() const;
	
	[[nodiscard]] const sockaddr_in& get_address() const;
	
	[[nodiscard]] client_process_function get_process_function() const;
	
	~server();
	
	void* extra;

#if defined(linux)
	
	static log_console log_;
	static log_console err_;

#endif

private:
#if defined(linux)
	
	static void* process_client(void* args);
	
	pthread_t main_thread = 0;
	int       socket;

#else
	
	static DWORD WINAPI process_client(void* args);
	
	SOCKET socket;
	HANDLE main_thread = nullptr;

#endif
	bool wait_for_child_threads = false;
	
	int                     max_clients;
	struct sockaddr_in      address;
	client_process_function process_function;
#if defined(linux)
	static pthread_mutex_t mutex;
#endif
	static int server_threads;
};

// #definition-begin server

int server::server_threads    = 0;

#if defined(linux)

log_console     server::log_(stdout);
log_console     server::err_(stderr);
pthread_mutex_t server::mutex = PTHREAD_MUTEX_INITIALIZER;


server::server(int max_clients, const sockaddr_in& address, client_process_function process_function, void* extra) :
		max_clients(max_clients), address(address), process_function(process_function), extra(extra)
{
	log << color::green << "socket init...\nserver address: " << color::yellow << inet_ntoa(address.sin_addr)
		<< color::green << ";\nsocket family: " << address.sin_family
		<< color::green << ";\nport = " << ntohs(address.sin_port)
		<< color::green << ";\n\tmax connections accept = " << max_clients
		<< color::green << ";" << color::reset << log_console::l_endent;
	errno = 0;
	socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (socket < 0)
	{
		error("socket() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ". socket : " << socket);
		return;
	}
	
	errno = 0;
	if (int ret = ::setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char*)(new int(1)), sizeof(int)); ret < 0)
	{
		error("setsockopt() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	
	log << color::green << "binding..." << color::reset << log_console::l_endent;
	errno = 0;
	if (int ret = ::bind(socket, (struct sockaddr*)&address, sizeof(address)); ret < 0)
	{
		error("bind() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	
	log << color::green << "success.\n" << color::reset
		<< color::green << "listening socket = " << color::reset << socket << color::green << " ...\n" << color::reset
		<< color::green << "listen..." << color::reset << log_console::l_endent;
	errno = 0;
	if (listen(socket, max_clients) < 0)
	{
		error("listen() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	log << color::green << "success." << color::reset << log_console::l_endent;
}

#else

server::server(int max_clients, const sockaddr_in& address, client_process_function process_function, void* extra) :
		max_clients(max_clients), address(address), process_function(process_function), extra(extra)
{
	log << "winsock lib init...\n";

	WSADATA wsa;

	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		error("WSAStartup() failed with error " << WSAGetLastError());
		return;
	}

	log << "done.\n";

	log << "socket init...\nserver address: " << inet_ntoa(address.sin_addr)
		<< ";\nsocket family: " << address.sin_family
		<< ";\nport = " << ntohs(address.sin_port)
		<< ";\n\tmax connections accept = " << max_clients
		<< ";\n";
	errno = 0;
	socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (socket == INVALID_SOCKET)
	{
		error("socket() failed with error " << GetLastError() << ". socket : " << socket);
		return;
	}
	
	errno = 0;
	if (int ret = ::setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char*)(new int(1)), sizeof(int)); ret < 0)
	{
		error("setsockopt() failed with error" << GetLastError());
		return;
	}
	
	log << "binding...\n";
	errno = 0;
	if (int ret = ::bind(socket, (struct sockaddr*)&address, sizeof(address)); ret < 0)
	{
		error("bind() failed with error " << GetLastError());
		return;
	}
	
	log << "success.\n"
		<< "listening socket = " << socket << " ...\n"
		<< "listen...\n";
	errno = 0;
	if (listen(socket, max_clients) < 0)
	{
		error("listen() failed with error " << GetLastError());
		return;
	}
	log << "success.\n";
}

#endif

#if defined(linux)

bool server::run(bool wait) const
{
	int threads_count          = 0, thread_id = 0;
	
	std::map<int, bool> is_client_processing;
	
	struct sockaddr_in address{ };
	socklen_t          addrlen = sizeof(address);
	
	int new_socket;
	
	while (true)
	{
		errno = 0;
		if (new_socket = ::accept(this->socket, (struct sockaddr*)&address, &addrlen); new_socket < 0)
		{
			error("accept() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
			if (errno == EBADF || errno == EINVAL)
			{
				return false;
			}
			return true;
		}
		
		log << color::green << "====== new connection ======\n socket = " << color::reset << new_socket
			<< color::green << "\n address = " << color::yellow << ::inet_ntoa(address.sin_addr)
			<< color::green << "\n port = " << color::reset << ::ntohs(address.sin_port)
			<< color::green << "\n\n============================" << color::reset << log_console::l_endent;
		
		auto* dat = new server_client_data{ };
		dat->socket                   = new_socket;
		dat->serv                     = const_cast<server*>(this);
		dat->address                  = address;
		dat->is_client_processing_ptr = &is_client_processing;
		dat->thread_id                = ++thread_id;
		dat->threads_count            = &++threads_count;
		dat->process_function         = process_function;
		
		log << color::green << "running client processing thread..." << color::reset << log_console::l_endent;
		
		pthread_t pthread;
		pthread_create(&pthread, nullptr, process_client, (void*)dat);
		::pthread_detach(pthread);
		
		log << color::green << "done." << color::reset << log_console::l_endent;
	}
	
	while (wait && threads_count > 0)
	{
		::usleep(10000);
	}
}

#else

bool server::run(bool wait) const
{
	int threads_count          = 0, thread_id = 0;
	
	std::map<SOCKET, bool> is_client_processing;

	struct sockaddr_in address { };
	int addrlen = sizeof(address);

	SOCKET new_socket;
	
	while (true)
	{
		errno = 0;
		if (new_socket = ::accept(this->socket, (struct sockaddr*)&address, &addrlen); new_socket < 0)
		{
			error("accept() failed with error " << GetLastError());
			if (errno == EBADF || errno == EINVAL)
			{
				return false;
			}
			return true;
		}
		
		log << "====== new connection ======\n socket = " << new_socket
			<< "\n address = " << ::inet_ntoa(address.sin_addr)
			<< "\n port = " << ::ntohs(address.sin_port)
			<< "\n\n============================\n";
		
		auto* dat = new server_client_data{ };
		dat->socket                   = new_socket;
		dat->serv                     = const_cast<server*>(this);
		dat->address                  = address;
		dat->is_client_processing_ptr = &is_client_processing;
		dat->thread_id                = ++thread_id;
		dat->threads_count            = &++threads_count;
		dat->process_function         = process_function;
		
		log << "running client processing thread...\n";

		CreateThread(nullptr, 0, process_client, (void*)dat, 0, 0);
		
		log << "done.\n";
	}
	
	while (wait && threads_count > 0)
	{
		Sleep(10);
	}
}

#endif

#if defined(linux)
void* server::server_thread(void* args)
#else
DWORD WINAPI server::server_thread(void* args)
#endif
{
	auto* server = static_cast<class server*>(args);
	while (server->run(server->wait_for_child_threads))
	{ }
	--server::server_threads;
#if defined(linux)
	return new bool(true);
#else
	return 0;
#endif
}

void server::run_server_thread(bool wait_for_child_threads)
{
	this->wait_for_child_threads = wait_for_child_threads;
	++server::server_threads;
#if defined(linux)
	log << color::light << color::yellow << "starting main server thread..." << log_console::l_endent;
	pthread_create(&this->main_thread, nullptr, server_thread, static_cast<void*>(const_cast<server*>(this)));
	pthread_detach(this->main_thread);
	log << color::light << color::yellow << "done." << log_console::l_endent;
#else
	log << "starting main server thread...\n";
	this->main_thread = CreateThread(nullptr, 0, server_thread, static_cast<void*>(const_cast<server*>(this)), 0, 0);
	log << "done.\n";
#endif
}

inline void server::wait_for_all_servers()
{
	while (server::server_threads > 0)
	{
#if defined(linux)
		::usleep(10000);
#else
		Sleep(10);
#endif
	}
}

#if defined(linux)

void server::open_port_in_iptables(uint16_t port)
{
	if (!geteuid())
	{
		log << color::light << color::green << "executing opening ports command..." << color::reset << log_console::l_endent;
		std::string cmd("sudo iptables -A ");
		system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		log << color::light << color::green << "executed." << color::reset << log_console::l_endent;
	}
}

void server::close_port_in_iptables(uint16_t port)
{
	if (!geteuid())
	{
		log << color::light << color::green << "executing opening ports command..." << color::reset << log_console::l_endent;
		std::string cmd("sudo iptables -D ");
		system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		log << color::light << color::green << "executed." << color::reset << log_console::l_endent;
	}
}

void server::get_machine_ip(struct ifreq& result, const char* interface_name)
{
	int fd = ::socket(AF_INET, SOCK_DGRAM, 0);
	
	result.ifr_ifru.ifru_addr.sa_family = AF_INET;
	
	/*eth0 - define the ifr_name - port name where network attached.*/
	::memcpy(result.ifr_ifrn.ifrn_name, interface_name, IFNAMSIZ - 1);
	
	/*Accessing network interface information by passing address using ioctl.*/
	::ioctl(fd, SIOCGIFADDR, &result);
	
	::close(fd);
}

std::vector<struct ifaddrs*>& server::list_all_network_interfaces()
{
	auto* result = new std::remove_cvref_t<decltype(list_all_network_interfaces())>();
	
	struct ifaddrs* ifaddr, * ifa;
	
	if (::getifaddrs(&ifaddr) == -1)
	{
		error("getifaddrs() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << ".");
		return *result;
	}
	
	/* Walk through linked list, maintaining head pointer so we
	   can free list later */
	for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
	{
		if (ifa->ifa_addr == nullptr || ifa->ifa_addr->sa_family != AF_PACKET) continue;
		result->push_back(ifa);
	}
	return *result;
}

void* server::process_client(void* args)
{
	pthread_mutex_lock(&mutex);
	struct server_client_data& data = *static_cast<struct server_client_data*>(args);
	int client_socket = data.socket;
	log << color::green << "\nsocket : " << client_socket << log_console::l_endent;
	if ((*data.is_client_processing_ptr)[client_socket])
	{
		return new bool(true);
	}
	(*data.is_client_processing_ptr)[client_socket] = true;
	pthread_mutex_unlock(&mutex);
	
	log << color::green << "processing client...\n\tthread_no = " << data.thread_id << color::green << ";" << color::reset << log_console::l_endent;
	while (data.process_function(data.socket, data.address, data.serv))
	{ }
	log << color::light << "job finished.\n\tthread_no = " << data.thread_id << ";" << color::reset << log_console::l_endent;
	return new bool(true);
}

int server::get_socket() const
{
	return socket;
}

#else

DWORD WINAPI server::process_client(void* args)
{
	struct server_client_data& data = *static_cast<struct server_client_data*>(args);
	int client_socket = data.socket;
	log << "\nsocket : " << client_socket << "\n";
	if ((*data.is_client_processing_ptr)[client_socket])
	{
		return 0;
	}
	(*data.is_client_processing_ptr)[client_socket] = true;

	log << "processing client...\n\tthread_no = " << data.thread_id << ";\n";
	while (data.process_function(data.socket, data.address, data.serv))
	{
	}
	log << "job finished.\n\tthread_no = " << data.thread_id << ";\n";
	return 0;
}

SOCKET server::get_socket() const
{
	return socket;
}

#endif

int server::get_max_clients() const
{
	return max_clients;
}

const sockaddr_in& server::get_address() const
{
	return address;
}

client_process_function server::get_process_function() const
{
	return process_function;
}

server::~server()
{
#if defined(linux)
	pthread_kill(this->main_thread, 0);
	::close(this->socket);
#else
	TerminateThread(this->main_thread, 0);
	closesocket(this->socket);
	WSACleanup();
#endif
}

// #definition-end server

class inet_io
{
public:
	inet_io() = default;

#if defined(linux)
	
	explicit inet_io(int socket);

#else
	
	explicit inet_io(SOCKET socket);

#endif

#if defined(linux)
	
	template <size_t max_attempts = 0>
	bool write(const void* data, size_t size);

#else
	
	bool write(const char* data, size_t size);

#endif

#if defined(linux)
	
	ssize_t read(void* data, size_t size, bool non_block = false);
	
	[[nodiscard]] int get_socket() const;

#else
	
	size_t read(char* data, size_t size);

	[[nodiscard]] SOCKET get_socket() const;

#endif
	
	inline operator bool() const;

#if defined(linux)
	
	static log_console log_;
	static log_console err_;

#endif

protected:
	template <typename type>
	friend inline inet_io& operator<<(inet_io& io, type data);
	
	template <typename type>
	friend inline inet_io& operator>>(inet_io& io, type& data);

#if defined(linux)
	int socket;
#else
	SOCKET socket;
#endif
	bool sucess = true;
};

// #definition-begin inet_io

#if defined(linux)
log_console inet_io::log_(stdout);
log_console inet_io::err_(stderr);
#endif

#if defined(linux)

inet_io::inet_io(int socket) : socket(socket)
{ }

#else

inet_io::inet_io(SOCKET socket) : socket(socket)
{ }

#endif

#if defined(linux)

template <size_t max_attempts>
bool inet_io::write(const void* data, size_t size)
#else
bool inet_io::write(const char* data, size_t size)
#endif
{
	this->sucess = true;

#if defined(linux)
	ssize_t wrote = ::write(this->socket, data, size);
	if (wrote < 0)
	{
		goto fail;
	}
	
	for (size_t attempt = 0; wrote < size && attempt < max_attempts; ++attempt)
	{
		log << color::light << color::green << "wrote only " << wrote << color::green << "bytes of data - trying to write rest." << color::reset
			<< log_console::l_endent;
		*reinterpret_cast<const char**>(&data) += wrote;
		size -= wrote;
		wrote = ::write(this->socket, data, size);
		if (wrote < 0)
		{
			goto fail;
		}
	}
	
	if (!wrote)
	{
		goto fail;
	}
	
	return wrote == size;
#else
	int wrote = send(this->socket, data, size, 0);
	if (wrote == SOCKET_ERROR)
	{
		error("send() failed with error: " << WSAGetLastError());
		goto fail;
	}
	return wrote == size;
#endif

fail:
#if defined(linux)
	error("write() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
#endif
	this->sucess = false;
	return false;
}

#if defined(linux)

ssize_t inet_io::read(void* data, size_t size, bool non_block)
{
	this->sucess = true;
	int flags;
	if (non_block)
	{
		flags = fcntl(this->socket, F_GETFL, 0);
		if (::fcntl(this->socket, F_SETFL, flags | O_NONBLOCK) < 0)
		{
			error("fcntl() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
			this->sucess = false;
		}
	}
	
	ssize_t read = ::read(this->socket, data, size);
	if (read <= 0)
	{
		error("read() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
		this->sucess = false;
	}
	
	if (non_block)
	{
		if (::fcntl(this->socket, F_SETFL, flags))
		{
			error("fcntl() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
			this->sucess = false;
		}
	}
	
	return read;
}

int inet_io::get_socket() const
{
	return socket;
}

#else

size_t inet_io::read(char* data, size_t size)
{
	this->sucess = true;

	int read = ::recv(this->socket, data, size, 0);
	if (read <= 0)
	{
		error("read() failed with error: " << GetLastError());
		this->sucess = false;
		return 0;
	}

	return read;
}

SOCKET inet_io::get_socket() const
{
	return socket;
}

#endif

inet_io::operator bool() const
{
	return this->sucess;
}

template <typename type>
inline inet_io& operator<<(inet_io& io, type data)
{
	if constexpr(std::is_same_v<std::remove_cvref_t<type>, const char*>)
	{
		io.write(data, strlen(data));
	}
	else if constexpr(std::is_same_v<std::remove_cvref_t<type>, const wchar_t*>)
	{
#if defined(linux)
		io.write(
				data,
#else
				io.write((const char*)data,
#endif
				wcslen(data) * sizeof(*data));
	}
	else if constexpr(std::is_same_v<std::remove_cvref_t<type>, std::string> || std::is_same_v<std::remove_cvref_t<type>, std::wstring>)
	{
#if defined(linux)
		io.write(
				data.c_str(),
#else
				io.write((const char*)data.c_str(),
#endif
				data.size() * sizeof(typename std::remove_cvref_t<type>::value_type));
	}
	else if constexpr(std::is_arithmetic_v<type>)
	{
		io.write((const char*)&data, sizeof(data));
	}
	else
	{
		static_cast<type>(new type); // invalid data type
	}
	return io;
}

template <typename type>
inline inet_io& operator>>(inet_io& io, type& data)
{
	if constexpr(!std::is_const_v<type> && std::is_arithmetic_v<type>)
	{
		io.read(reinterpret_cast<char*>(&data), sizeof(data));
	}
	else
	{
		static_cast<type>(new type); // invalid data type
	}
	return io;
}

// #definition-end inet_io

class client : public inet_io
{
public:
	client(const in_addr& server_address, uint16_t port);
	
	bool connect();
	
	[[nodiscard]] uint16_t get_port() const;
	
	[[nodiscard]] const sockaddr_in& get_server_address() const;
	
	~client();

private:
	uint16_t           port;
	struct sockaddr_in server_address;
};

// #definition-begin client

client::client(const in_addr& server_address, uint16_t port) : server_address{AF_INET, htons(port), server_address}, port(port)
{
#if defined(linux)
	log << color::green << "socket init...\nserver address: " << color::yellow << inet_ntoa(this->server_address.sin_addr)
		<< color::green << ";\nsocket family: " << this->server_address.sin_family
		<< color::green << ";\nport = " << ntohs(this->server_address.sin_port) << color::green << ";"
		<< color::reset << log_console::l_endent;
	
	errno = 0;
	this->socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (this->socket < 0)
	{
		error("socket init failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ". socket : " << socket);
		return;
	}
	
	log << color::green << "success." << color::reset << log_console::l_endent;
#else
	log << "socket init...\nserver address: " << inet_ntoa(this->server_address.sin_addr)
		<< ";\nsocket family: " << this->server_address.sin_family
		<< ";\nport = " << ntohs(this->server_address.sin_port) << ";\n";
	this->socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (this->socket == INVALID_SOCKET)
	{
		error("socket init failed with error: " << GetLastError());
		return;
	}

	log << "success.\n";
#endif
}

bool client::connect()
{
#if defined(linux)
	log << color::green << "connecting..." << color::reset << log_console::l_endent;
	errno = 0;
	if (::connect(socket, (struct sockaddr*)&this->server_address, sizeof(this->server_address)) < 0)
	{
		error("connection failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return false;
	}
	
	log << color::green << "success." << color::reset << log_console::l_endent;
#else
	log << "connecting...\n";
	if (::connect(socket, (struct sockaddr*)&this->server_address, sizeof(this->server_address)) == SOCKET_ERROR)
	{
		error("connect() failed with error: " << GetLastError());
		closesocket(socket);
		socket = INVALID_SOCKET;
		return false;
	}

	log << "success.\n";
#endif
	return true;
}

uint16_t client::get_port() const
{
	return port;
}

#if defined(linux)

const sockaddr_in& client::get_server_address() const
{
	return server_address;
}

#endif

client::~client()
{
#if defined(linux)
	::close(this->socket);
#else
	closesocket(this->socket);
#endif
}

// #definition-end client

#endif // INET_COMM