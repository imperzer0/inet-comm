//
// Created by imper on 6/21/21.
//

#ifndef INET_COMM
#define INET_COMM


#include <cstring>
#include <thread>
#include <iostream>
#include <map>
#include <vector>
#include <cassert>

#if defined(linux)

#include <sys/socket.h>
#include <arpa/inet.h>
#include <csignal>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <log-console>
#include <ifaddrs.h>

#endif

#if defined(linux)
#define log log_ << log_console::l_lock << l_time << l_location
#define err err_ << log_console::l_lock << l_time << l_location

#define error(message) (log << color::red << color::bold << "error" << color::reset << " : " << color::red << color::italic << message << color::reset << log_console::l_endent)
#define fatal_error(message) error(message); throw std::runtime_error(message)
#else
#define error(message) (std::cerr << "error" << " : " << message << "\n")
#define fatal_error(message) error(message); throw std::runtime_error(message)
#endif

class suppress_signal
{
public:
	explicit suppress_signal(int _sig) : _sig(_sig)
	{
		::signal(_sig, _sig_handle);
	}
	
	~suppress_signal()
	{
		::signal(this->_sig, SIG_DFL);
	}

#if defined(linux)
	
	static void enable_log(bool status = true);
	
	static void enable_err(bool status = true);

#endif

private:
	int _sig;
	
	static void _sig_handle(int _sig);

#if defined(linux)
	static log_console log_;
	static log_console err_;
#endif
};

log_console suppress_signal::log_(stdout);
log_console suppress_signal::err_(stderr);

class server;

typedef bool (* client_process_function)(int socket, const sockaddr_in& address, server* server);

struct server_client_data
{
#if defined(linux)
	int         socket;
	sockaddr_in address;
	std::map<int, bool>* is_client_processing_ptr;
#endif
	server* serv;
	client_process_function process_function;
	int                     thread_id;
};

class server
{
public:
#if defined(linux)
	
	server(int max_clients, const struct sockaddr_in& address, client_process_function process_function, void* extra = nullptr);

#endif
	
	[[nodiscard]] bool run() const;

#if defined(linux)
	
	static void* server_thread(void* args);

#endif
	
	void run_server_thread();

#if defined(linux)
	
	static void open_port_in_iptables(uint16_t port);
	
	static void close_port_in_iptables(uint16_t port);
	
	static void get_machine_ip(struct ifreq& result, const char* interface_name);
	
	static std::vector<struct ifaddrs*>& list_all_network_interfaces();
	
	[[nodiscard]] int get_socket() const;

#endif
	
	[[nodiscard]] int get_max_clients() const;

#if defined(linux)
	
	[[nodiscard]] const sockaddr_in& get_address() const;

#endif
	
	[[nodiscard]] client_process_function get_process_function() const;
	
	~server();
	
	void* extra;

#if defined(linux)
	static log_console log_;
	static log_console err_;
#endif

private:
#if defined(linux)
	
	static void* process_client(void* args);
	
	pthread_t main_thread;
	int       socket;
#endif
	int max_clients;
#if defined(linux)
	struct sockaddr_in address;
#endif
	client_process_function process_function;
#if defined(linux)
	static pthread_mutex_t mutex;
#endif
};

// #definition-begin suppress_signal

void suppress_signal::_sig_handle(int _sig)
{
	error(::strsignal(_sig));
}

void suppress_signal::enable_log(bool status)
{
	if (status) log_ << log_console::on;
	else log_ << log_console::off;
}

void suppress_signal::enable_err(bool status)
{
	if (status) log_ << log_console::on;
	else log_ << log_console::off;
}

// #definition-end suppress_signal

// #definition-begin server

#if defined(linux)
log_console     server::log_(stdout);
log_console     server::err_(stderr);
pthread_mutex_t server::mutex = PTHREAD_MUTEX_INITIALIZER;
#endif


#if defined(linux)

server::server(int max_clients, const sockaddr_in& address, client_process_function process_function, void* extra) :
		max_clients(max_clients), address(address), process_function(process_function), extra(extra)
{
	log << color::green << "socket init...\nserver address: " << color::yellow << inet_ntoa(address.sin_addr)
		<< color::green << ";\nsocket family: " << address.sin_family
		<< color::green << ";\nport = " << ntohs(address.sin_port)
		<< color::green << ";\n\tmax connections accept = " << max_clients
		<< color::green << ";" << color::reset << log_console::l_endent;
	errno = 0;
	socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (socket < 0)
	{
		error("socket() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ". socket : " << socket);
		return;
	}
	
	errno = 0;
	if (int ret = ::setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char*)(new int(1)), sizeof(int)); ret < 0)
	{
		error("setsockopt() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	
	log << color::green << "binding..." << color::reset << log_console::l_endent;
	errno = 0;
	if (int ret = ::bind(socket, (struct sockaddr*)&address, sizeof(address)); ret < 0)
	{
		error("bind() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	
	log << color::green << "success.\n" << color::reset
		<< color::green << "listening socket = " << color::reset << socket << color::green << " ...\n" << color::reset
		<< color::green << "listen..." << color::reset << log_console::l_endent;
	errno = 0;
	if (listen(socket, max_clients) < 0)
	{
		error("listen() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return;
	}
	log << color::green << "success." << color::reset << log_console::l_endent;
}

#endif

bool server::run() const
{
	int threads_count          = 0;

#if defined(linux)
	std::map<int, bool> is_client_processing;
	
	struct sockaddr_in address{ };
	socklen_t          addrlen = sizeof(address);
	
	int new_socket;
#endif
	
	while (true)
	{
#if defined(linux)
		errno = 0;
		if (new_socket = ::accept(this->socket, (struct sockaddr*)&address, &addrlen); new_socket < 0)
		{
			error("accept() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
			if (errno == EBADF || errno == EINVAL)
			{
				return false;
			}
			return true;
		}
		
		log << color::green << "====== new connection ======\n socket = " << color::reset << new_socket
			<< color::green << "\n address = " << color::yellow << ::inet_ntoa(address.sin_addr)
			<< color::green << "\n port = " << color::reset << ::ntohs(address.sin_port)
			<< color::green << "\n\n============================" << color::reset << log_console::l_endent;
		
		auto* dat = new server_client_data{ };
		dat->socket                   = new_socket;
		dat->serv                     = const_cast<server*>(this);
		dat->address                  = address;
		dat->is_client_processing_ptr = &is_client_processing;
		dat->thread_id                = ++threads_count;
		dat->process_function         = process_function;
		
		log << color::green << "running client processing thread..." << color::reset << log_console::l_endent;
		
		pthread_t pthread;
		pthread_create(&pthread, nullptr, process_client, (void*)dat);
		::pthread_detach(pthread);
		
		log << color::green << "done." << color::reset << log_console::l_endent;
#endif
	}
}

#if defined(linux)

void* server::server_thread(void* args)
#endif
{
	auto* server = static_cast<class server*>(args);
	while (server->run())
	{ }
#if defined(linux)
	return new bool(true);
#endif
}

void server::run_server_thread()
{
#if defined(linux)
	log << color::light << color::yellow << "starting main server thread..." << log_console::l_endent;
	pthread_create(&this->main_thread, nullptr, server_thread, static_cast<void*>(const_cast<server*>(this)));
	pthread_detach(this->main_thread);
	log << color::light << color::yellow << "done." << log_console::l_endent;
#endif
}

#if defined(linux)

void server::open_port_in_iptables(uint16_t port)
{
	if (!geteuid())
	{
		log << color::light << color::green << "executing opening ports command..." << color::reset << log_console::l_endent;
		std::string cmd("sudo iptables -A ");
		system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		log << color::light << color::green << "executed." << color::reset << log_console::l_endent;
	}
}

void server::close_port_in_iptables(uint16_t port)
{
	if (!geteuid())
	{
		log << color::light << color::green << "executing opening ports command..." << color::reset << log_console::l_endent;
		std::string cmd("sudo iptables -D ");
		system((cmd + "INPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		system((cmd + "OUTPUT -p tcp --dport " + std::to_string(port) + " -j ACCEPT").c_str());
		log << color::light << color::green << "executed." << color::reset << log_console::l_endent;
	}
}

void server::get_machine_ip(struct ifreq& result, const char* interface_name)
{
	int fd = ::socket(AF_INET, SOCK_DGRAM, 0);
	
	result.ifr_ifru.ifru_addr.sa_family = AF_INET;
	
	/*eth0 - define the ifr_name - port name where network attached.*/
	::memcpy(result.ifr_ifrn.ifrn_name, interface_name, IFNAMSIZ - 1);
	
	/*Accessing network interface information by passing address using ioctl.*/
	::ioctl(fd, SIOCGIFADDR, &result);
	
	::close(fd);
}

std::vector<struct ifaddrs*>& server::list_all_network_interfaces()
{
	auto* result = new std::remove_cvref_t<decltype(list_all_network_interfaces())>();
	
	struct ifaddrs* ifaddr, * ifa;
	
	if (::getifaddrs(&ifaddr) == -1)
	{
		error("getifaddrs() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << ".");
		return *result;
	}
	
	/* Walk through linked list, maintaining head pointer so we
	   can free list later */
	for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
	{
		if (ifa->ifa_addr == nullptr || ifa->ifa_addr->sa_family != AF_PACKET) continue;
		result->push_back(ifa);
	}
	return *result;
}

void* server::process_client(void* args)
{
	pthread_mutex_lock(&mutex);
	struct server_client_data& data = *static_cast<struct server_client_data*>(args);
	int client_socket = data.socket;
	log << color::green << "\nsocket : " << client_socket << log_console::l_endent;
	if ((*data.is_client_processing_ptr)[client_socket])
	{
		return new bool(true);
	}
	(*data.is_client_processing_ptr)[client_socket] = true;
	pthread_mutex_unlock(&mutex);
	
	log << color::green << "processing client...\n\tthread_no = " << data.thread_id << color::green << ";" << color::reset << log_console::l_endent;
	while (data.process_function(data.socket, data.address, data.serv))
	{ }
	log << color::light << "job finished.\n\tthread_no = " << data.thread_id << ";" << color::reset << log_console::l_endent;
	return new bool(true);
}

int server::get_socket() const
{
	return socket;
}

#endif

int server::get_max_clients() const
{
	return max_clients;
}

#if defined(linux)

const sockaddr_in& server::get_address() const
{
	return address;
}

#endif

client_process_function server::get_process_function() const
{
	return process_function;
}

server::~server()
{
#if defined(linux)
	pthread_kill(this->main_thread, 0);
	::close(this->socket);
#endif
}

// #definition-end server

class inet_io
{
public:
	inet_io() = default;

#if defined(linux)
	
	explicit inet_io(int socket);

#endif
	
	template <size_t max_attempts = 0>
	bool write(const void* data, size_t size);

#if defined(linux)
	
	ssize_t read(void* data, size_t size, bool non_block = false);
	
	[[nodiscard]] int get_socket() const;

#endif
	
	inline operator bool() const;

#if defined(linux)
	static log_console log_;
	static log_console err_;
#endif

protected:
	template <typename type>
	friend inline inet_io& operator<<(inet_io& io, type data);
	
	template <typename type>
	friend inline inet_io& operator>>(inet_io& io, type& data);

#if defined(linux)
	int socket;
#endif
	bool sucess = true;
};

// #definition-begin inet_io

#if defined(linux)
log_console inet_io::log_(stdout);
log_console inet_io::err_(stderr);
#endif

#if defined(linux)

inet_io::inet_io(int socket) : socket(socket)
{ }

#endif

template <size_t max_attempts>
bool inet_io::write(const void* data, size_t size)
{
	this->sucess = true;

#if defined(linux)
	ssize_t wrote = ::write(this->socket, data, size);
	if (wrote < 0)
	{
		goto fail;
	}
	
	for (size_t attempt = 0; wrote < size && attempt < max_attempts; ++attempt)
	{
		log << color::light << color::green << "wrote only " << wrote << color::green << "bytes of data - trying to write rest." << color::reset
			<< log_console::l_endent;
		*reinterpret_cast<const char**>(&data) += wrote;
		size -= wrote;
		wrote = ::write(this->socket, data, size);
		if (wrote < 0)
		{
			goto fail;
		}
	}
	
	if (!wrote)
	{
		goto fail;
	}
	
	return wrote == size;
#endif

fail:
#if defined(linux)
	error("write() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
#endif
	this->sucess = false;
	return false;
}

#if defined(linux)

ssize_t inet_io::read(void* data, size_t size, bool non_block)
{
	this->sucess = true;
	int flags;
	if (non_block)
	{
		flags = fcntl(this->socket, F_GETFL, 0);
		if (::fcntl(this->socket, F_SETFL, flags | O_NONBLOCK) < 0)
		{
			error("fcntl() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
			this->sucess = false;
		}
	}
	
	ssize_t read = ::read(this->socket, data, size);
	if (read <= 0)
	{
		error("read() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
		this->sucess = false;
	}
	
	if (non_block)
	{
		if (::fcntl(this->socket, F_SETFL, flags))
		{
			error("fcntl() failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ".");
			this->sucess = false;
		}
	}
	
	return read;
}

int inet_io::get_socket() const
{
	return socket;
}

#endif

inet_io::operator bool() const
{
	return this->sucess;
}

template <typename type>
inline inet_io& operator<<(inet_io& io, type data)
{
	if constexpr(std::is_same_v<std::remove_cvref_t<type>, const char*>)
	{
		io.write(data, strlen(data));
	}
	else if constexpr(std::is_same_v<std::remove_cvref_t<type>, const wchar_t*>)
	{
		io.write(data, wcslen(data));
	}
	else if constexpr(std::is_same_v<std::remove_cvref_t<type>, std::string> || std::is_same_v<std::remove_cvref_t<type>, std::wstring>)
	{
		io.write(data.c_str(), data.size());
	}
	else if constexpr(std::is_arithmetic_v<type>)
	{
		io.write(&data, sizeof(data));
	}
	else
	{
		static_cast<type>(new type); // invalid data type
	}
	return io;
}

template <typename type>
inline inet_io& operator>>(inet_io& io, type& data)
{
	if constexpr(!std::is_const_v<type> && std::is_arithmetic_v<type>)
	{
		io.read(&data, sizeof(data));
	}
	else
	{
		static_cast<type>(new type); // invalid data type
	}
	return io;
}

// #definition-end inet_io

class client : public inet_io
{
public:
#if defined(linux)
	
	client(const in_addr& server_address, uint16_t port);

#endif
	
	bool connect();
	
	[[nodiscard]] uint16_t get_port() const;
	
	[[nodiscard]] const sockaddr_in& get_server_address() const;
	
	~client();

private:
	uint16_t port;
#if defined(linux)
	struct sockaddr_in server_address;
#endif
};

// #definition-begin client

#if defined(linux)

client::client(const in_addr& server_address, uint16_t port) : server_address{AF_INET, htons(port), server_address}, port(port)
{
	log << color::green << "socket init...\nserver address: " << color::yellow << inet_ntoa(this->server_address.sin_addr)
		<< color::green << ";\nsocket family: " << this->server_address.sin_family
		<< color::green << ";\nport = " << ntohs(this->server_address.sin_port) << color::green << ";"
		<< color::reset << log_console::l_endent;
	
	errno = 0;
	this->socket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (this->socket < 0)
	{
		error("socket init failed " << errno << " " << color::bold << ::strerror(errno) << color::reset << color::red << ". socket : " << socket);
		return;
	}
	
	log << color::green << "success." << color::reset << log_console::l_endent;
}

#endif

bool client::connect()
{
	
	log << color::green << "connecting..." << color::reset << log_console::l_endent;
	errno = 0;
	if (::connect(socket, (struct sockaddr*)&this->server_address, sizeof(this->server_address)) < 0)
	{
		error("connection failed " << errno << " " << color::bold << ::strerror(errno) << color::reset);
		return false;
	}
	
	log << color::green << "success." << color::reset << log_console::l_endent;
	return true;
}

uint16_t client::get_port() const
{
	return port;
}

#if defined(linux)

const sockaddr_in& client::get_server_address() const
{
	return server_address;
}

#endif

client::~client()
{
#if defined(linux)
	::close(this->socket);
#endif
}

// #definition-end client

#endif // INET_COMM